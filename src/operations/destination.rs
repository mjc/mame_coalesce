use std::{
    collections::{BTreeMap, HashSet},
    fs::{File, OpenOptions},
    io::{BufReader, BufWriter, Read, Write},
};

use camino::{Utf8Path, Utf8PathBuf};
use compress_tools::{ArchiveContents, ArchiveIterator};
use indicatif::ProgressBar;
use log::{debug, error};
use rayon::prelude::*;
use zip::{write::FileOptions, ZipWriter};

use crate::{
    models::{Game, Rom, RomFile},
    MameResult,
};

pub fn write_all_zips(
    games: &BTreeMap<Game, HashSet<(Rom, RomFile)>>,
    destination: &Utf8Path,
    zip_bar: &ProgressBar,
) -> Vec<Utf8PathBuf> {
    // this is by far the ugliest code I've ever written in any language
    // I'm sorry
    // TODO: major refactor
    let paths = games
        .par_iter()
        .filter_map(|(game, rom_and_romfile_pair)| {
            let bundles: Vec<DestinationBundle> = rom_and_romfile_pair
                .iter()
                .map(|(rom, rom_file)| DestinationBundle::from_rom_and_rom_file(rom, rom_file))
                .collect();

            let zip_file_path = zip_file_path(destination, game.name());
            debug!("Creating zip file: {:?}", zip_file_path);

            let (mut zip_writer, zip_options) = open_destination_zip(&zip_file_path);
            for bundle in bundles {
                bundle.zip(&mut zip_writer, zip_options).ok()?;
            }
            zip_writer.finish().ok()?;
            zip_bar.inc(1);
            Some(zip_file_path)
        })
        .collect();
    paths
}

// definitely should return a Result
fn open_destination_zip(zip_file_path: &Utf8Path) -> (ZipWriter<BufWriter<File>>, FileOptions) {
    let zip_file = OpenOptions::new()
        .create(true)
        .append(false)
        .write(true)
        .open(zip_file_path)
        .unwrap();
    let writer = BufWriter::new(zip_file);
    let mut zip_writer = ZipWriter::new(writer);
    let zip_options = FileOptions::default().compression_method(zip::CompressionMethod::Deflated);
    zip_writer.set_comment("Generated by mame_coalesce");
    (zip_writer, zip_options)
}

fn zip_file_path(destination: &Utf8Path, game_name: &str) -> Utf8PathBuf {
    let zip_file_path = Utf8PathBuf::new()
        .join(destination)
        .join(format!("{}.zip", game_name));
    zip_file_path
}

struct DestinationBundle {
    archive_path: String,
    destination_name: String,
    source_name: String,
    in_archive: bool,
}

impl DestinationBundle {
    pub fn from_rom_and_rom_file(rom: &Rom, rom_file: &RomFile) -> Self {
        let destination_name = rom.name().to_owned();
        let source_name = rom_file.name().to_owned();
        let archive_path = rom_file.path().to_owned();
        let in_archive = rom_file.in_archive();
        Self {
            archive_path,
            destination_name,
            source_name,
            in_archive,
        }
    }

    pub fn zip(
        &self,
        zip_writer: &mut zip::ZipWriter<std::io::BufWriter<File>>,
        zip_options: zip::write::FileOptions,
    ) -> MameResult<String> {
        // TODO: zip_writer.raw_copy_file_rename/2 to skip recompressing for zip files

        if self.in_archive() {
            debug!(
                "Adding file {} from archive: {}",
                self.source_name(),
                self.archive_path()
            );
            Self::copy_from_archive(
                self.archive_path(),
                self.source_name(),
                zip_writer,
                self.destination_name(),
                zip_options,
            )
        } else {
            debug!("Adding file not in archive: {:?}", self.source_name());
            Self::copy_bare_file(
                self.archive_path(),
                zip_writer,
                self.destination_name(),
                zip_options,
            )
        }
    }

    pub fn copy_bare_file(
        source_path: &str,
        zip_writer: &mut ZipWriter<BufWriter<File>>,
        destination_name: &str,
        zip_options: FileOptions,
    ) -> MameResult<String> {
        let input_file = File::open(source_path)?;
        let input_reader = BufReader::new(input_file);
        zip_writer.start_file(destination_name, zip_options)?;
        for byte in input_reader.bytes() {
            zip_writer.write_all(&[byte?])?;
        }
        Ok(destination_name.to_owned())
    }

    pub fn copy_from_archive(
        source_path: &str,
        source_name: &str,
        zip_writer: &mut ZipWriter<BufWriter<File>>,
        destination_name: &str,
        zip_options: FileOptions,
    ) -> MameResult<String> {
        let input_file = File::open(source_path)?;
        let input_reader = BufReader::new(input_file);
        let mut iter = ArchiveIterator::from_read(input_reader)?;
        let mut current_name = String::new();
        for content in &mut iter {
            match content {
                ArchiveContents::StartOfEntry(name) => {
                    current_name = name;
                    if current_name == source_name {
                        debug!("Found file: {:?}", current_name);
                        zip_writer.start_file(destination_name, zip_options)?;
                    }
                }
                ArchiveContents::DataChunk(chunk) => {
                    if current_name == source_name {
                        zip_writer.write_all(&chunk)?;
                    }
                }
                ArchiveContents::EndOfEntry => {
                    zip_writer.flush()?;
                }
                ArchiveContents::Err(e) => {
                    error!("{:?}", e);
                }
            }
        }
        Ok(destination_name.to_owned())
    }

    /// Get a reference to the destination bundle's archive path.
    pub fn archive_path(&self) -> &str {
        self.archive_path.as_ref()
    }

    /// Get a reference to the destination bundle's destination name.
    pub fn destination_name(&self) -> &str {
        self.destination_name.as_ref()
    }

    /// Get a reference to the destination bundle's source name.
    pub fn source_name(&self) -> &str {
        self.source_name.as_ref()
    }

    /// Get the destination bundle's in archive.
    pub const fn in_archive(&self) -> bool {
        self.in_archive
    }
}
