use std::{
    fs::{File, OpenOptions},
    io::{BufReader, BufWriter, Read, Write},
    path::{Path, PathBuf},
};

use compress_tools::{ArchiveContents, ArchiveIterator};
use indicatif::ProgressBar;
use log::{debug, error};
use rayon::prelude::*;
use zip::{write::FileOptions, ZipWriter};

use crate::models::{Game, Rom, RomFile};

pub fn write_all_zips(
    games: std::collections::BTreeMap<Game, std::collections::HashSet<(Rom, RomFile)>>,
    destination: &Path,
    zip_bar: &ProgressBar,
) {
    games.par_iter().for_each(|(game, rom_and_romfile_pair)| {
        let bundles: Vec<DestinationBundle> = rom_and_romfile_pair
            .iter()
            .map(|(rom, rom_file)| DestinationBundle::from_rom_and_rom_file(rom, rom_file))
            .collect();

        let zip_file_path = zip_file_path(destination, game.name());
        debug!("Creating zip file: {:?}", zip_file_path.to_str().unwrap());

        let (mut zip_writer, zip_options) = open_destination_zip(zip_file_path);

        bundles
            .iter()
            .for_each(|bundle| bundle.zip(&mut zip_writer, zip_options));
        zip_writer.finish().unwrap();
        zip_bar.inc(1);
    });
}

fn open_destination_zip(zip_file_path: PathBuf) -> (ZipWriter<BufWriter<File>>, FileOptions) {
    let zip_file = OpenOptions::new()
        .create(true)
        .append(false)
        .write(true)
        .open(zip_file_path)
        .unwrap();
    let writer = BufWriter::new(zip_file);
    let mut zip_writer = ZipWriter::new(writer);
    let zip_options = FileOptions::default().compression_method(zip::CompressionMethod::Deflated);
    zip_writer.set_comment("Generated by mame_coalesce");
    (zip_writer, zip_options)
}

fn zip_file_path(destination: &Path, game_name: &str) -> PathBuf {
    let zip_file_path = PathBuf::new()
        .join(destination)
        .join(format!("{}.zip", game_name));
    zip_file_path
}

struct DestinationBundle {
    archive_path: String,
    destination_name: String,
    source_name: String,
    in_archive: bool,
}

impl DestinationBundle {
    pub fn from_rom_and_rom_file(rom: &Rom, rom_file: &RomFile) -> Self {
        let destination_name = rom.name().to_string();
        let source_name = rom_file.name().to_string();
        let archive_path = rom_file.path().to_string();
        let in_archive = rom_file.in_archive();
        Self {
            archive_path,
            destination_name,
            source_name,
            in_archive,
        }
    }

    pub fn zip(
        &self,
        zip_writer: &mut zip::ZipWriter<std::io::BufWriter<File>>,
        zip_options: zip::write::FileOptions,
    ) {
        // TODO: zip_writer.raw_copy_file_rename/2 to skip recompressing for zip files

        if self.in_archive() {
            debug!(
                "Adding file {} from archive: {}",
                self.source_name(),
                self.archive_path()
            );
            Self::copy_from_archive(
                self.archive_path(),
                self.source_name(),
                zip_writer,
                self.destination_name(),
                zip_options,
            );
        } else {
            debug!("Adding file not in archive: {:?}", self.source_name());
            Self::copy_bare_file(
                self.archive_path(),
                zip_writer,
                self.destination_name(),
                zip_options,
            );
        }
    }

    pub fn copy_bare_file(
        source_path: &str,
        zip_writer: &mut ZipWriter<BufWriter<File>>,
        destination_name: &str,
        zip_options: FileOptions,
    ) {
        let input_file = File::open(source_path).unwrap();
        let input_reader = BufReader::new(input_file);
        zip_writer
            .start_file(destination_name, zip_options)
            .unwrap();
        input_reader.bytes().for_each(|b| {
            zip_writer.write_all(&[b.unwrap()]).unwrap();
        });
    }

    pub fn copy_from_archive(
        source_path: &str,
        source_name: &str,
        zip_writer: &mut ZipWriter<BufWriter<File>>,
        destination_name: &str,
        zip_options: FileOptions,
    ) {
        let input_file = File::open(source_path).unwrap();
        let input_reader = BufReader::new(input_file);
        let mut iter = ArchiveIterator::from_read(input_reader).unwrap();
        let mut current_name = String::default();
        for content in &mut iter {
            match content {
                ArchiveContents::StartOfEntry(name) => {
                    current_name = name.to_string();
                    if current_name == source_name {
                        debug!("Found file: {:?}", current_name);
                        zip_writer
                            .start_file(destination_name, zip_options)
                            .unwrap();
                    }
                }
                ArchiveContents::DataChunk(chunk) => {
                    if current_name == source_name {
                        zip_writer.write_all(&chunk).unwrap();
                    }
                }
                ArchiveContents::EndOfEntry => {
                    zip_writer.flush().unwrap();
                }
                ArchiveContents::Err(e) => {
                    error!("{:?}", e)
                }
            }
        }
    }

    /// Get a reference to the destination bundle's archive path.
    pub fn archive_path(&self) -> &str {
        self.archive_path.as_ref()
    }

    /// Get a reference to the destination bundle's destination name.
    pub fn destination_name(&self) -> &str {
        self.destination_name.as_ref()
    }

    /// Get a reference to the destination bundle's source name.
    pub fn source_name(&self) -> &str {
        self.source_name.as_ref()
    }

    /// Get the destination bundle's in archive.
    pub fn in_archive(&self) -> bool {
        self.in_archive
    }
}
